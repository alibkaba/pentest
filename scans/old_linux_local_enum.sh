#!/bin/bash
################################################################################
## [Author]:
## Ali Kaba www.alibkaba.com
## This script was written to mimic most of Mike Czumak's (T_v3rn1x) python
## version in bash.  Thank you!
## https://github.com/sleventyeleven/linuxprivchecker/blob/master/linuxprivchecker.py
## I also got some inspiration from the following sites/tools:
## https://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/
## http://pentestmonkey.net/tools/audit/unix-privesc-check
##------------------------------------------------------------------------------
## [Details]:
## This script is intended to be executed locally on a Linux box to enumerate
## basic system info and search for common privilege escalation vectors such as
## world writable files, misconfigurations, clear-text passwords, and others.
##------------------------------------------------------------------------------
## [Warning]:
## This tool may be used for legal purposes only.  Users take full
## responsibility for any actions performed using this tool.  The author accepts
## no liability for damage caused by this tool.  If you do not accept these
## condition then you are prohibited from using this tool.
##
## This script comes as-is with no promise of functionality or accuracy.
## Ensure that you have the appropriate legal permission before running it
## someone else's system.
##------------------------------------------------------------------------------
## [MIT License]:
##
## Copyright (c) [2017] [Ali Kaba]
##
## Permission is hereby granted, free of charge, to any person obtaining a copy
## of this software and associated documentation files (the "Software"), to deal
## in the Software without restriction, including without limitation the rights
## to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
## copies of the Software, and to permit persons to whom the Software is
## furnished to do so, subject to the following conditions:
##
## The above copyright notice and this permission notice shall be included in
## all copies or substantial portions of the Software.
##
## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
## IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
## FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
## AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
## LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
## OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
## SOFTWARE.
################################################################################

operatingSYSTEM(){
  cmdTITLE="OPERATING SYSTEM";
  cmdSTATUStitle;

  # distribution
  cmdSUBTITLE="Distribution";
  cmdRESPONSE=$($catCMD /etc/*-release 2>&1;);
  cmdSTATUSsubtitle;

  # kernel
  cmdSUBTITLE="Kernel";
  cmdRESPONSE=$(if [ -f /proc/version ]; then $catCMD /proc/version 2>&1; else $unameCMD -a 2>&1; fi;);
  cmdSTATUSsubtitle;

  # hostname
  cmdSUBTITLE="Environment Variables";
  cmdRESPONSE=$($envCMD | $grepCMD -v "LS_COLORS" 2>&1;);
  cmdSTATUSsubtitle;

  # printer
  cmdSUBTITLE="Printer";
  cmdRESPONSE=$($lpstatCMD -a 2>&1;);
  cmdSTATUSsubtitle;
}

netWORK(){
  cmdTITLE="NETWORK";
  cmdSTATUStitle;

  # nic
  cmdSUBTITLE="Network Interfaces";
  cmdRESPONSE=$(if [ -f $ifconfigCMD ]; then $ifconfigCMD 2>&1; else $ipCMD a 2>&1; fi;);
  cmdSTATUSsubtitle;

  # dns resolver
  cmdSUBTITLE="DNS Resolver";
  cmdRESPONSE=$($catCMD /etc/resolv.conf 2>&1;);
  cmdSTATUSsubtitle;

  # hostname
  cmdSUBTITLE="Hostname";
  cmdRESPONSE=$($hostnameCMD 2>&1;);
  cmdSTATUSsubtitle;
}

userACCOUNTS(){
  cmdTITLE="USERS";
  cmdSTATUStitle;

  # who logged last on the system
  cmdSUBTITLE="All users";
  cmdRESPONSE=$($catCMD /etc/passwd 2>&1;);
  cmdSTATUSsubtitle;

  # list id
  cmdSUBTITLE="My ID & Group(s)";
  cmdRESPONSE=$($idCMD 2>&1;);
  cmdSTATUSsubtitle;

  # who is on the system
  cmdSUBTITLE="Who's logged right now";
  cmdRESPONSE=$($whoCMD 2>&1; w 2>&1;);
  cmdSTATUSsubtitle;

  # who logged last
  cmdSUBTITLE="Who's logged last";
  cmdRESPONSE=$($lastCMD);
  cmdSTATUSsubtitle;

  # list super users
  cmdSUBTITLE="Super users";
  cmdRESPONSE=$($catCMD /etc/passwd | $awkCMD -F: '($3 == 0) { print $1 }' 2>&1;);
  cmdSTATUSsubtitle;

  # list shadow file
  cmdSUBTITLE="Shadow file";
  cmdRESPONSE=$($catCMD /etc/shadow 2>&1;);
  cmdSTATUSsubtitle;
}

fileSYSTEMS(){
  cmdTITLE="FILE SYSTEMS";
  cmdSTATUStitle;

  # checking root's home folder
  cmdSUBTITLE="root's home folder accessibility";
  cmdRESPONSE=$($lsCMD -lt /root/ 2>&1;);
  cmdSTATUSsubtitle;

  # list world writeable directories owned by user/group root
  cmdSUBTITLE="World Writeables Directories for User/Group 'root'";
  cmdRESPONSE=$($findCMD / -perm -o+w -type d -user root -group root | $grepCMD -v /proc | $grepCMD -v "Permission denied";);
  cmdSTATUSsubtitle;

  # list world writeable directories owned by other usersroot
  cmdSUBTITLE="World Writeables Directories for non-root Users";
  cmdRESPONSE=$($findCMD / -perm -o+w -type d ! -user root ! -group root | $grepCMD -v /proc | $grepCMD -v "Permission denied";);
  cmdSTATUSsubtitle;

  # list world writeable files
  cmdSUBTITLE="World Writeables Files";
  cmdRESPONSE=$($findCMD / -perm -o+w -type f | $grepCMD -v /proc | $grepCMD -v "Permission denied";);
  cmdSTATUSsubtitle;

  # Sticky bits, SUID & SGID files and directories
  cmdSUBTITLE="Sticky bits";
  cmdRESPONSE=$($findCMD / -perm -1000 -type d | $grepCMD -v /proc | $grepCMD -v "Permission denied";);
  cmdSTATUSsubtitle;
  cmdSUBTITLE="SUID";
  cmdRESPONSE=$($findCMD / -perm -g=s -type f | $grepCMD -v /proc | $grepCMD -v "Permission denied";);
  cmdSTATUSsubtitle;
  cmdSUBTITLE="GUID";
  cmdRESPONSE=$($findCMD / -perm -1000 -type d | $grepCMD -v /proc | $grepCMD -v "Permission denied";);
  cmdSTATUSsubtitle;

  # logs containing keyword 'password'


  # config files containing keyword 'password'
  cmdSUBTITLE="Configuration files containing keyword 'password'";
  cmdRESPONSE=$($findCMD / -name "*.conf" -print0 | xargs -0 grep -i -n "password" 2>/dev/null | $grepCMD -v "Permission denied";);
  cmdSTATUSsubtitle;
}

applicationSERVICES(){
  cmdTITLE="APPLICATIONS & SERVICES";
  cmdSTATUStitle;

  # installed packages

  # list running services
  cmdSUBTITLE="Running Services";
  cmdRESPONSE=$($psCMD aux -o user,pid,time,cmd;);
  cmdSTATUSsubtitle;

  # list sudo version
  cmdSUBTITLE="Sudo version";
  cmdRESPONSE=$($sudoCMD -V;);
  cmdSTATUSsubtitle;

  # list processes and packages running as root or other superuser


  # look for installed tools
}

cleanUP(){
  cmdTITLE="CLEAN UP";
  cmdSTATUStitle;

  # clearing auth.log
  cmdSUBTITLE="Clearing /var/log/auth.log";
  cmdRESPONSE=$(echo " " > /var/log/auth.log;);
  cmdSTATUSsubtitle;

  # clearing current user bash history
  cmdSUBTITLE="Clearning bash_history";
  cmdRESPONSE=$(echo " " > ~/.bash_history;);
  cmdSTATUSsubtitle;

  # clearing current session history
  cmdSUBTITLE="Clearing Current Session History";
  cmdRESPONSE=$(history -c;);
  cmdSTATUSsubtitle;

  # setting history max lines to 0
  cmdSUBTITLE="Setting history max lines to 0";
  cmdRESPONSE=$(export HISTFILESIZE=0;);
  cmdSTATUSsubtitle;

  # setting history max cmds to 0
  cmdSUBTITLE="Setting history max cmds to 0";
  cmdRESPONSE=$(export HISTSIZE=0;);
  cmdSTATUSsubtitle;
}

cmdSTATUStitle(){
  echo -e "${LGREEN}=============================================";
  echo -e "${LGREEN}[*] $cmdTITLE...";
  echo -e "${LGREEN}=============================================${RESET}";
  printf "\n";
  sleep .5s;
}

cmdSTATUSsubtitle(){
  if [ $? -eq 0 ]; then
    echo -e "${LGREEN}[+] $cmdSUBTITLE${GREEN}";
    printf "$cmdRESPONSE\n\n${RESET}";
  else
    echo -e "${LRED}[!] $cmdSUBTITLE${ORANGE}";
    printf "$cmdRESPONSE\n\n${RESET}";
  fi
  sleep .5s;
}

# lookup bin in various pathes so that I don't depent on the $PATH env
lookupBIN(){
  if [[ -e /bin/$1 ]]; then
    echo /bin/$1;
  elif [[ -e /sbin/$1 ]]; then
    echo /sbin/$1;
  elif [[ -e /usr/bin/$1 ]]; then
    echo /usr/bin/$1;
  elif [[ -e /usr/local/$1 ]]; then
    echo /usr/local/$1;
  elif [[ -e /usr/local/bin/$1 ]]; then
    echo /usr/local/bin/$1;
  elif [[ -e /usr/local/sbin/$1 ]]; then
    echo /urs/local/sbin/$1;
  else
    echo $1": command not found";
    # this is to give me a fail status
    fdsafsda 2>/dev/null;
  fi
}

# text colors
RESET='\033[0m'; # No Color
LRED='\033[1;31m';
ORANGE='\033[0;33m';
LGREEN='\033[1;32m';
GREEN='\033[0;32m';
LBLUE='\033[1;34m';
cmdTITLE='';
cmdRESPONSE='';

# initializing commands so that I don't depent on the $PATH env
catCMD=$(lookupBIN cat);
unameCMD=$(lookupBIN uname);
envCMD=$(lookupBIN env);
grepCMD=$(lookupBIN grep);
lpstatCMD=$(lookupBIN lpstat);
hostnameCMD=$(lookupBIN hostname);
idCMD=$(lookupBIN id);
whoCMD=$(lookupBIN who);
lastCMD=$(lookupBIN last);
awkCMD=$(lookupBIN awk);
psCMD=$(lookupBIN ps);
ifconfigCMD=$(lookupBIN ifconfig);
ipCMD=$(lookupBIN ip);
lsCMD=$(lookupBIN ls);
findCMD=$(lookupBIN find);
sudoCMD=$(lookupBIN sudo);

echo -e "${LBLUE}=============================================";
echo -e "================= L I N U X =================";
echo -e "================= L O C A L =================";
echo -e "=========== E N U M E R A T I O N ===========";
echo -e "===== B Y = https://github.com/alibkaba =====";
echo -e "=============================================${RESET}\n\n";

start(){
  operatingSYSTEM;
  netWORK;
  userACCOUNTS;
  fileSYSTEMS;
  applicationSERVICES;
  cleanUP;
  $RESET;
}

start;
